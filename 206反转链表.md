给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。  
示例：  
输入：head = [1,2,3,4,5]  
输出：[5,4,3,2,1]  

测试链接：https://leetcode.cn/problems/reverse-linked-list  

算法思路：申请pre和next两个节点，next指向下一个需要处理的节点，防止丢失元素。head指向的是当前需要处理元素，也是反转链表的首节点，pre的指向反转链表后首节点的下一个元素

源代码：
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //定义两个指针pre、next,用来记录前后节点
        ListNode* pre = nullptr;
        ListNode* next = nullptr;
        //定义while循环,当head为nullptr时结束循环
        while( head != nullptr)
        {
            next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
};
```