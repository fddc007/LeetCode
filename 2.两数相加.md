给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储一位数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例:  
输入：l1 = [2,4,3],  l2 = [5,6,4]  
输出：[7,0,8]  
解释：342 + 465 = 807.  

测试链接:https://leetcode.cn/problems/add-two-numbers/description/  

算法思路:  
1. 用cur1和cur2来记录当前参与运算的节点,运算结果有产生进位和不产生进位两种可能,用变量ad来记录,0表示没有,1表示产生进位.运算的式子则为cur1.vual+cur2.vual+ad.  
2. 采用循环对每一位进行运算,当一个链表走到末尾时应当结束循环,但是另外一个链表的节点可能与进位相加产生新的进位,如9+1(ad=1)的情况,因此循环结束条件为:cur1!=nullptr || cur2!=nullptr  
3. 当有一个链表走到空时,往后的没有节点参与运算,可用0来代替后续的运算,如cur1 == nullptr?0,cur1.next
4. 当循环结束,判断最后的进位,如果为1,则还需添加一个节点

源代码:  
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int ad = 0; //ad记录进位
        ListNode* cur1 = l1;//记录当前l1参加运算的节点
        ListNode* cur2 = l2;//记录当前l2参加运算的节点
        //定义for循环，当cur1,cur2都为空时结束循环，否则向后迭代
        for
        (
            int val = 0,sum =0;//记录要写入下一节点的值,以及当前节点的值
            cur1 != nullptr || cur2 != nullptr;
            cur1 = (cur1 != nullptr? cur1->next : nullptr),
            cur2 = (cur2 != nullptr? cur2->next : nullptr)
        )
        {
            //求和
            sum = (cur1 == nullptr? 0:cur1->val) +(cur2 == nullptr? 0:cur2->val) + ad;
            val = sum % 10;
            ad = sum / 10;
            cur1->val = val;
            if(cur2 != nullptr && cur1->next == nullptr && cur2->next != nullptr)
            {
                cur1->next = new ListNode();
            }
            if(cur1->next == nullptr && ad ==1 && (cur2 == nullptr || cur2->next == nullptr))
            {
                cur1->next = new ListNode();
            }
        }

        return l1;
    }
};
```

复杂度分析:  
1. 时间复杂度:由于只需要遍历一遍链表,则复杂度为O(N)
2. 空间复杂度:由于只是额外申请常数个辅助变量来记录,因此复杂度为O(1)